[condition][]xcb object=xcb : XOMContainerBean()
[condition][]Evaluate=eval
[condition][]the field_tag {field} is exists=xcb.xpath({field}).booleanValue()
[condition][]the {field} is populated=((new Populated()).isPopulated((xcb.xpath({field})).stringValue()))
[condition][]the {field} matches the pattern {pattern}=((new SpecialFormat()).isPatternMatches((xcb.xpath({field})).stringValue(),{pattern}))
[condition][]the {field} do_not_matches_the pattern {pattern}=((new SpecialFormat()).isPatternNotMatches((xcb.xpath({field})).stringValue(),{pattern}))
[condition][]the {field} is not populated=((new Populated()).isNotPopulated(xcb.xpath({field}).stringValue()))
[condition][]the {field} equals {value}=((new Equals()).isEquals(((xcb.xpath({field})).stringValue()),{value}))
[condition][]the {field} not_equals {value}=(!((new Equals()).isEquals(((xcb.xpath({field})).stringValue()),{value})))
[condition][]the {field} is equal to values {values}=((new Equals()).isEqualToValues((xcb.xpath({field}).stringValue()),{values}))
[condition][]it is not true that_the {field} is equal to values {values}=(!((new Equals()).isEqualToValues((xcb.xpath({field}).stringValue()),{values})))
[condition][]the {field} is not equal to values {values}=((new Equals()).isNotEqualToValues((xcb.xpath({field}).stringValue()),{values}))
[condition][]it is not true that_the_field {field1} is_not_equal_to_field {field2}=(!(field1NotEqualsField2(xcb, (xcb.xpath({field1}).stringValue()), {field2})))
[condition][]the_field {field1} is_not_equal_to_field {field2}=(field1NotEqualsField2(xcb, (xcb.xpath({field1}).stringValue()), {field2}))
[consequence][]call_Fun_EU_TCIDMultipleOTHER_with error code {ecode} and message {emsg}=Fun_EU_TCIDMultipleOTHER(xcb,{ecode},{emsg})
[consequence][]call_Fun_EU_SATHTableNegate_with error code {ecode} and message {emsg}=Fun_EU_SATHTableNegate(xcb,{ecode},{emsg})
[condition][]the_value_of_any_occurance_of {field1} equals_value_of_any_occurance_of {field2}=anyOccurenceEqualToValue(xcb,{field1},{field2})
[condition][]it is not true that_the maximum length of {field} is {value}=(!((new LengthCheck()).checkMaximumlength(((xcb.xpath({field})).stringValue()),{value})))
[condition][]the maximum length of {field} is {value}=((new LengthCheck()).checkMaximumlength(((xcb.xpath({field})).stringValue()),{value}))
[condition][]the {field} is AlphaNumeric without following Special Character set {value}=((new DatatypeCheck()).checkAlphaNumericWithOutSPSet(((xcb.xpath({field})).stringValue()),{value}))
[condition][]it is not true that_the {field} is AlphaNumeric without following Special Character set {value}=(!((new DatatypeCheck()).checkAlphaNumericWithOutSPSet(((xcb.xpath({field})).stringValue()),{value})))
[condition][]the {pos} position of {field} is equal to {value}=((new Position()).positionOftagValueEqualToValue({pos}, ((xcb.xpath({field}).stringValue())), {value}))
[condition][]it is not true that_the {pos} position of {field} is equal to {value}=(!((new Position()).positionOftagValueEqualToValue({pos}, ((xcb.xpath({field}).stringValue())), {value})))
[condition][]the {pos} position of {field} is not equal to {value}=(!((new Position()).positionOftagValueEqualToValue({pos}, ((xcb.xpath({field}).stringValue())), {value})))
[condition][]the {field} has telephone number format as {format}=((new TNFormat()).tnFormatIs((xcb.xpath({field}).stringValue()), {format}))
[condition][]it is not true that_the {field} has telephone number format as {format}=(!((new TNFormat()).tnFormatIs((xcb.xpath({field}).stringValue()), {format})))
[condition][]the length of {field} is {value}=((new LengthCheck()).checkLength((xcb.xpath({field}).stringValue()), {value}))
[condition][]it is not true that_the length of {field} is {value}=(!((new LengthCheck()).checkLength((xcb.xpath({field}).stringValue()), {value})))
[condition][]the {field} is Numeric=((new DatatypeCheck()).checkNumeric((xcb.xpath({field}).stringValue())))
[condition][]it is not true that_the {field} is Numeric=(!((new DatatypeCheck()).checkNumeric((xcb.xpath({field}).stringValue()))))
[condition][]the {field} is greater than {value}=((new Equals()).isGreaterThan((xcb.xpath({field}).stringValue()), {value}))
[condition][]it is not true that_the {field} is greater than {value}=(!((new Equals()).isGreaterThan((xcb.xpath({field}).stringValue()), {value})))
[condition][]the {field} contains {values}=((new Contains()).contains((xcb.xpath({field}).stringValue()), {values}))
[condition][]it is not true that_the {field} contains {values}=(!((new Contains()).contains((xcb.xpath({field}).stringValue()), {values})))
[condition][]the {field} has a character {char} followed and preceeded by a numeric=((new Contains()).characterPreceededOrFollowedByNumeric((xcb.xpath({field}).stringValue()),{char}))
[condition][]it is not true that_the {field} has a character {char} followed and preceeded by a numeric=(!((new Contains()).characterPreceededOrFollowedByNumeric((xcb.xpath({field}).stringValue()),{char})))
[condition][]the {field} is AlphaNumeric=((new DatatypeCheck()).checkAlphaNumeric((xcb.xpath({field}).stringValue())))
[condition][]it is not true that_the {field} is AlphaNumeric=(!((new DatatypeCheck()).checkAlphaNumeric((xcb.xpath({field}).stringValue()))))
[condition][]the {field} is AlphaNumeric_with following Special Character set {values}=((new DatatypeCheck()).checkAlphaNumericSPSet((xcb.xpath({field}).stringValue()), {values}))
[condition][]it is not true that_the {field} is AlphaNumeric_with following Special Character set {values}=(!((new DatatypeCheck()).checkAlphaNumericSPSet((xcb.xpath({field}).stringValue()), {values})))
[condition][]the {field} is Alpha=((new DatatypeCheck()).checkAlpha((xcb.xpath({field}).stringValue())))
[condition][]it is not true that_the {field} is Alpha=(!((new DatatypeCheck()).checkAlpha((xcb.xpath({field}).stringValue()))))
[condition][]the position of Alpha is {pos} in {field}=((new DatatypeCheck()).checkPositionAlpha({pos}, (xcb.xpath({field}).stringValue())))
[condition][]it is not true that_the position of Alpha is {pos} in {field}=(!((new DatatypeCheck()).checkPositionAlpha({pos}, (xcb.xpath({field}).stringValue()))))
[condition][]the {pos} position of {field} is not_equal to values {values}=((new Position()).positionOftagValueNotEqualToValues({pos},(xcb.xpath({field}).stringValue()),{values}))
[condition][]Positions {pos1} and {pos2} of {field} is equal to values {values}=((new Position()).twoPositionValueofTagEqualToValues({pos1}, {pos2}, ((xcb.xpath({field}).stringValue())), {values}))
[condition][]it is not true that_Positions {pos1} and {pos2} of {field} is equal to values {values}=(!((new Position()).twoPositionValueofTagEqualToValues({pos1}, {pos2}, ((xcb.xpath({field}).stringValue())), {values})))
[condition][]the {field} is compared with its position {pos1} to {pos2} with values {values}=((new Position()).compareCharAtAnyPositionWithAnyNumberOfValue((xcb.xpath({field}).stringValue()), {pos1}, {pos2}, {values}))
[condition][]it is not true that_the {field} is compared with its position {pos1} to {pos2} with values {values}=(!((new Position()).compareCharAtAnyPositionWithAnyNumberOfValue((xcb.xpath({field}).stringValue()), {pos1}, {pos2}, {values})))
[condition][]the field {field} contain character {char} followed by space=((new Contains()).characterFollowedBySpace((xcb.xpath({field}).stringValue()),{char}))
[condition][]it is not true that_the field {field} contain character {char} followed by space=(!((new Contains()).characterFollowedBySpace((xcb.xpath({field}).stringValue()),{char})))
[condition][]the {field} contains_double virgule and not preceeded and followed by alphanumeric=((new Contains()).doubleVirgleNotPreceededAndFollowedByAlphaNumeric((xcb.xpath({field}).stringValue())))
[condition][]it is not true that_the {field} contains_double virgule and not preceeded and followed by alphanumeric=(!((new Contains()).doubleVirgleNotPreceededAndFollowedByAlphaNumeric((xcb.xpath({field}).stringValue()))))
[condition][]the {field} contains_ampersand preceded by a space=((new SpaceCheck()).isAmpersandprecspace((xcb.xpath({field}).stringValue())))
[condition][]it is not true that_the {field} contains_ampersand preceded by a space=(!((new SpaceCheck()).isAmpersandprecspace((xcb.xpath({field}).stringValue()))))
[condition][]the {field1} not_equals_to the {field2}=((new Equals()).isNotEquals((xcb.xpath({field1}).stringValue()),(xcb.xpath({field2}).stringValue())))
[condition][]it is not true that_the {field1} not_equals_to the {field2}=(!((new Equals()).isNotEquals((xcb.xpath({field1}).stringValue()),(xcb.xpath({field2}).stringValue()))))
[condition][]the {field} contains_single paranthesis and not contained in another parenthesis=((new Contains()).checkSingleParanthesis((xcb.xpath({field}).stringValue())))
[condition][]it is not true that_the {field} contains single paranthesis and not contained in another parenthesis=(!((new Contains()).checkSingleParanthesis((xcb.xpath({field}).stringValue()))))
[condition][]virguleFollowedByVirgule {field}=((new Contains()).virguleFollowedByVirgule((xcb.xpath({field}).stringValue())))
[condition][]it is not true that_virguleFollowedByVirgule{field}=(!((new Contains()).virguleFollowedByVirgule((xcb.xpath({field}).stringValue()))))
[condition][]the {field} contains_consecutive spaces=((new Contains()).spaceFollowedBySpace((xcb.xpath({field}).stringValue())))
[condition][]it is not true that_the {field} contains_consecutive spaces=(!((new Contains()).spaceFollowedBySpace((xcb.xpath({field}).stringValue()))))
[condition][]characterPreceededAndFollowedByAlpha with {field} and {char}=((new Contains()).characterPreceededAndFollowedByAlpha(xcb.xpath({field}).stringValue(),{char}))
[condition][]it is not true that_characterPreceededAndFollowedByAlpha with {field} and {char}=(!((new Contains()).characterPreceededAndFollowedByAlpha(xcb.xpath({field}).stringValue(),{char})))
[condition][]characterPreceededAndFollowedByAlphaNumeric with {field} and {char}=((new Contains()).characterPreceededAndFollowedByAlphaNumeric(xcb.xpath({field}).stringValue(),{char}))
[condition][]it is not true that_characterPreceededAndFollowedByAlphaNumeric with {field} and {char}=(!((new Contains()).characterPreceededAndFollowedByAlphaNumeric(xcb.xpath({field}).stringValue(),{char})))
[condition][]characterFollowedByAlpha with {field} and {char}=((new Contains()).characterFollowedByAlpha(xcb.xpath({field}).stringValue(),{char}))
[condition][]it is not true that_characterFollowedByAlpha with {field} and {char}=(!((new Contains()).characterFollowedByAlpha(xcb.xpath({field}).stringValue(),{char})))
[condition][]twoAdjacentCharactersPreceededAndFollowedByAlpha with {field} and {char}=((new Contains()).twoAdjacentCharactersPreceededAndFollowedByAlpha(xcb.xpath({field}).stringValue(),{char}))
[condition][]it is not true that_twoAdjacentCharactersPreceededAndFollowedByAlpha with {field} and {char}=(!((new Contains()).twoAdjacentCharactersPreceededAndFollowedByAlpha(xcb.xpath({field}).stringValue(),{char})))
[condition][]Position {pos} of {field} field is equal to values {values}=((new Position()).positionOftagValueEqualToValues({pos},(xcb.xpath({field}).stringValue()),{values}))
[condition][]it is not true that_Position {pos} of {field} field is equal to values {values}=(!((new Position()).positionOftagValueEqualToValues({pos},(xcb.xpath({field}).stringValue()),{values})))
[condition][]there is no {section} section=(xcb.xpath({section}).stringValue().length() == 0)
[condition][]it is not true that_there is no {section} section=(!(xcb.xpath({section}).stringValue().length() == 0))
[condition][]the {field}is Alpha_with Special Characters Set {values}=((new DatatypeCheck()).checkAlphaSPSet((xcb.xpath({field}).stringValue()),{values}))
[condition][]it is not true that_the {field}is Alpha_with Special Characters Set {values}=(!((new DatatypeCheck()).checkAlphaSPSet((xcb.xpath({field}).stringValue()),{values})))
[condition][]the position {pos1} and {pos2} of {field} is between {val1} and {val2}=((new RangeOfValues()).twoFieldPositionInRange({pos1}, {pos2}, (xcb.xpath({field}).stringValue()),{val1}, {val2}))
[condition][]it is not true that_the position {pos1} and {pos2} of {field} is between {val1} and {val2}=(!((new RangeOfValues()).twoFieldPositionInRange({pos1}, {pos2}, (xcb.xpath({field}).stringValue()),{val1}, {val2})))
[condition][]the {field} is prohibited=((new Prohibited()).isProhibited((xcb.xpath({field})).stringValue()))
[condition][]it is not true that_the {field} is prohibited=((new Prohibited()).isProhibited((xcb.xpath({field})).stringValue()))
[condition][]the {field} is Numeric_with Special Characters Set {value}=((new DatatypeCheck()).checkNumericSPSet(((xcb.xpath({field})).stringValue()),{value}))
[condition][]it is not true that_the {field} is Numeric_with Special Characters Set {value}=(!((new DatatypeCheck()).checkNumericSPSet(((xcb.xpath({field})).stringValue()),{value})))
[condition][]Is the {field1} less than {field2} in the format {format}=((new DateFormatCheck()).isFieldDateLessThanComparisonDateInspecifiedFormat((xcb.xpath({field1}).stringValue()),(xcb.xpath({field2}).stringValue()),{format}))
[condition][]it is not true that_Is the {field1} less than {field2} in the format {format}=(!((new DateFormatCheck()).isFieldDateLessThanComparisonDateInspecifiedFormat((xcb.xpath({field1}).stringValue()),(xcb.xpath({field2}).stringValue()),{format})))
[condition][]the values at position {pos11} to {pos12} of {field1} equals values at {pos21} to {pos22} of {field2}=((new Position()).twoPositionRangeValueofTagEqualToValueOfAnotherTwoPosition({pos11}, {pos12}, (xcb.xpath({field1}).stringValue()), {pos21}, {pos22}, (xcb.xpath({field2}).stringValue())))
[condition][]it is not true that_the values at position {pos11} to {pos12} of {field1} equals values at {pos21} to {pos22} of {field2}=(!((new Position()).twoPositionRangeValueofTagEqualToValueOfAnotherTwoPosition({pos11}, {pos12}, (xcb.xpath({field1}).stringValue()), {pos21}, {pos22},(xcb.xpath({field2}).stringValue()))))
[condition][]the length of {field} is_between {value1} and {value2}=((new LengthCheck()).checkMinMaxLength((xcb.xpath({field}).stringValue()), {value1}, {value2}))
[condition][]it is not true that_the length of {field} is_between {value1} and {value2}=(!((new LengthCheck()).checkMinMaxLength((xcb.xpath({field}).stringValue()), {value1}, {value2})))
[consequence][]the_errorCode {ecode} with_message {emsg} for_the_field {field} in_section {section} value1 {value1} Fun_multipleNotCheckMinMax {value2}=multipleNotCheckMinMax(xcb,{section},{field},{value1},{value2},{ecode},{emsg})
[condition][]lastCharPositionNotNumeric for the field {field}=((new DatatypeCheck()).lastCharPositionNotNumeric((xcb.xpath({field}).stringValue())))
[condition][]it is not true that_lastCharPositionNotNumeric for the field {field}=(!((new DatatypeCheck()).lastCharPositionNotNumeric((xcb.xpath({field}).stringValue()))))
[condition][]the {field} has all uppercase characters=((new CapitalLetterCheck()).isAllUpperCase((xcb.xpath({field}).stringValue())))
[condition][]it is not true that_the {field} has all uppercase characters=(!((new CapitalLetterCheck()).isAllUpperCase((xcb.xpath({field}).stringValue()))))
[condition][]the {field} has time format as {format}=((new TimeFormatCheck()).timeFormat((xcb.xpath({field}).stringValue()), {format}))
[condition][]it is not true that_the {field} has time format as {format}=(!((new TimeFormatCheck()).timeFormat((xcb.xpath({field}).stringValue()), {format})))
[condition][]three character range {range1} to {range2} of the {field} is not_populated or blank=((new SpaceCheck()).existenceOfSpaceInSpecRange((xcb.xpath({field}).stringValue()), {range1}, {range2}))
[condition][]it is not true that_three character range {range1} to {range2} of the {field} is not_populated or blank=(!((new SpaceCheck()).existenceOfSpaceInSpecRange((xcb.xpath({field}).stringValue()), {range1}, {range2})))
[condition][]the {field} has the date format as {format}=((new DateFormatCheck()).dateCheck((xcb.xpath({field}).stringValue()), {format}))
[condition][]it is not true that_the {field} has the date format as {format}=(!((new DateFormatCheck()).dateCheck((xcb.xpath({field}).stringValue()), {format})))
[condition][]the {field} is_according to the specified {format}=((new SpecialFormat()).isFieldAccordingToFormat((xcb.xpath({field}).stringValue()), {format}))
[condition][]it is not true that_the {field} is_according to the specified {format}=(!((new SpecialFormat()).isFieldAccordingToFormat((xcb.xpath({field}).stringValue()), {format})))
[condition][]the {field} is AlphaNumeric_with only space as special character=((new DatatypeCheck()).checkAlphaNumericWithSpaceAsSpecialCharacter((xcb.xpath({field}).stringValue())))
[condition][]it is not true that_the {field} is AlphaNumeric_with only space as special character=(!((new DatatypeCheck()).checkAlphaNumericWithSpaceAsSpecialCharacter((xcb.xpath({field}).stringValue()))))
[condition][]the {field} contains_numeric characters=((new Contains()).containsNumeric((xcb.xpath({field}).stringValue())))
[condition][]it is not true that_the {field} contains_numeric characters=(!((new Contains()).containsNumeric((xcb.xpath({field}).stringValue()))))
[condition][]the {pos1} to {pos2} position of the {field} is less than or equal to {pos3} to {pos4} position=((new Position()).posToPosOfTagIsLessThanOrEqualToPosToPos({pos1}, {pos2}, (xcb.xpath({field}).stringValue()),{pos3}, {pos4}))
[condition][]it is not true that_the {pos1} to {pos2} position of the {field} is less than or equal to {pos3} to {pos4} position=(!((new Position()).posToPosOfTagIsLessThanOrEqualToPosToPos({pos1}, {pos2}, (xcb.xpath({field}).stringValue()),{pos3}, {pos4})))
[condition][]the {field1} is_less than {field2}=((new DateCheck()).isLessThan((xcb.xpath({field1}).stringValue()),(xcb.xpath({field2}).stringValue())))
[condition][]it is not true that_the {field1} is_less than {field2}=(!((new DateCheck()).isLessThan((xcb.xpath({field1}).stringValue()),(xcb.xpath({field2}).stringValue()))))
[condition][]the_datefield {field1} is greater than or equal to the datefield {field2} by one year=((new DateCheck()).isField1GreaterThanOrEqualToField2ByOneYear((xcb.xpath({field1}).stringValue()),(xcb.xpath({field2}).stringValue())))
[condition][]Check cancel Order for {field1} and {field2}=Fun_checkForCancelordervze(xcb,{field1},{field2})
[condition][]the {field} is_equal_or_greater than {value}=((new Equals()).isEqualOrGreaterThan(((xcb.xpath({field})).stringValue()),{value}))
[condition][]it is not true that_the {field} is_equal_or_greater than {value}=(!((new Equals()).isEqualOrGreaterThan(((xcb.xpath({field})).stringValue()),{value})))
[condition][]the {field} is_equal_or_less than {value}=((new Equals()).isEqualOrLessThan(((xcb.xpath({field})).stringValue()),{value}))
[condition][]it is not true that_the {field} is_equal_or_less than {value}=(!((new Equals()).isEqualOrLessThan(((xcb.xpath({field})).stringValue()),{value})))
[condition][]the {field} has format as {value}=((new SpecialFormat()).formatIs(((xcb.xpath({field})).stringValue()),{value}))
[condition][]it is not true that_the {field} has format as {value}=(!((new SpecialFormat()).formatIs(((xcb.xpath({field})).stringValue()),{value})))
[consequence][]the error code {errorCode} with message {errorMsg} for the field {xPath}=xcb.logError({errorCode},{errorMsg},{xPath})
[consequence][]execute the rule=
[consequence][]call_Fun_PSRLMulOR_with error code {ecode} and message {emsg}=Fun_PSRLMulOR(xcb,{ecode},{emsg})
[consequence][]call_Fun_PSISRMulORValues_with error code {ecode} and message {emsg}=Fun_PSISRMulORValues(xcb,{ecode},{emsg})
[consequence][]call_Fun_LS_CTIMultiple_with error code {ecode} and message {emsg}=Fun_LS_CTIMultiple(xcb,{ecode},{emsg})
[consequence][]call_Fun_DL_RTYMultipleLACT_with error code {ecode} and message {emsg}=Fun_DL_RTYMultipleLACT(xcb,{ecode},{emsg})
[consequence][]call_Fun_LS_chanpairMultipleOTHERNegate_with error code {ecode} and message {emsg}=Fun_LS_chanpairMultipleOTHERNegate(xcb,{ecode},{emsg})
[consequence][]call_Fun_DL_TOAMultipleOTHER_with error code {ecode} and message {emsg}=Fun_DL_TOAMultipleOTHER(xcb,{ecode},{emsg})
[consequence][]call_Fun_FieldWithMoreThanOneOCCValues_with error code {ecode} and message {emsg}=Fun_FieldWithMoreThanOneOCCValues(xcb,{ecode},{emsg})
[condition][]the {field} not preceeded and followed by {char}=((new Contains()).characterNotPreceededAndFollowedByNumeric((xcb.xpath({field}).stringValue()), {char}))
[condition][]it is not true that_the {field} not preceeded and followed by {char}=(!((new Contains()).characterNotPreceededAndFollowedByNumeric((xcb.xpath({field}).stringValue()), {char})))
[condition][]it is not true that_the occurance of {field} is equal to {count}=(NumOccOfSecNotEqualCount(xcb,{field},{count}))
[condition][]it is not true that_the value of {field1} is equal to number of occurance of {field2} in section {section}=(NumOccOfSecNotEqualFieldValue(xcb,{field1},{field2},{section}))
[condition][]any occurence of {field} in {section} are not populated=(AllOccOfFieldNotPop(xcb,{field},{section}))
[condition][]all occurence of {field} are not sequential=(AllOccOfFieldNotSequential(xcb,{field}))
[condition][]any occurence of {field} in {section} are populated=((AnyOccOfFieldPop(xcb,{field},{section})))
[condition][]Difference between pos 14-17 and pos 9-12 of {field} across the order_is greater than {num}=(countPortedNbrRangeformatvalues(xcb,{field},{num}))
[condition][]Check PIA Response for {field1} and {field2}=FunGetResponseXMLForResponseType(xcb,{field1},{field2})
[condition][]Check cancel Order for {field1} and {field2}=FunCancelOrderCheck(xcb,{field1},{field2})
[consequence][]the rule {ruleId} with error code {errorCode} with message {errorMsg} for the field {field} of section {section}=logMultipleError(xcb,{ruleId},{section},{field},{errorCode},{errorMsg})
[consequence][]call_Fun_DL_LVLMultipleOTHER_with error code {ecode} and message {emsg}=Fun_DL_LVLMultipleOTHER(xcb,{ecode},{emsg})
[consequence][]call_Fun_DL_LVL_sameLISTMultipleOTHER_with error code {ecode} and message {emsg}=Fun_DL_LVL_sameLISTMultipleOTHER(xcb,{ecode},{emsg})
[consequence][]call_Fun_PS_TNSMultiple_with error code {ecode} and message {emsg}=Fun_PS_TNSMultiple(xcb,{ecode},{emsg})
[consequence][]call_Fun_EU_TCNAMEMultipleOTHER_with error code {ecode} and message {emsg}=Fun_EU_TCNAMEMultipleOTHER(xcb,{ecode},{emsg})
[consequence][]call_Fun_LSNP_RLMultipleOR_with error code {ecode} and message {emsg}=Fun_LSNP_RLMultipleOR(xcb,{ecode},{emsg})
[consequence][]call_Fun_TOAMultipleOR_with error code {ecode} and message {emsg}=Fun_TOAMultipleOR(xcb,{ecode},{emsg})
[condition][]Rule {ruleID} multiple times {field} in {section} is populated=(moExists(xcb,{ruleID},{section},{field}))
[condition][]Rule {ruleID} multiple times {field} in {section} maximum length value {value}=(moMaxLength(xcb,{ruleID},{section},{field},{value}))
[condition][]Rule {ruleID} multiple times {field} in {section} is equal to {values}=(multiEquals(xcb,{ruleID},{section},{field},{values}))
[condition][]Rule {ruleID} multiple times {field} in {section} is not equal to {values}=((multiNotEquals(xcb,{ruleID},{section},{field},{values})))
[condition][]it is not true that_Rule {ruleID} multiple times {field} in {section} is Alpha_with Special Characters Set {values}=((AlphaSpecialChar(xcb,{ruleID},{section},{field},{values})))
[condition][]it is not true that_Rule {ruleID} multiple times {field} in {section} is Alpha=((isNotAlpha(xcb,{ruleID},{section},{field})))
[condition][]Rule {ruleID} multiple times {field} in {section} is Alpha=((isAlpha(xcb,{ruleID},{section},{field})))
[condition][]it is not true that_Rule {ruleID} multiple times {field} in {section} is Numeric=((isNotNumber(xcb,{ruleID},{section},{field})))
[condition][]Rule {ruleID} multiple times {field} in {section} is Numeric=((isNumber(xcb,{ruleID},{section},{field})))
[condition][]Rule {ruleID} multiple times_the {pos} position of {field} in {section} is not equal to values {values}=(PositionValue(xcb,{ruleID},{section},{field},{pos},{values}))
[condition][]Rule {ruleID} multiple times_the {field} in {section} is greater than {value}=(isGreaterThan(xcb,{ruleID},{section},{field},{value}))
[condition][]Rule {ruleID} multiple times_the {pos} position of {field} in {section} is equal to values {values}=(PositionValueEqual(xcb,{ruleID},{section},{field},{pos},{values}))
[condition][]it is not true that_Rule {ruleID} multiple times_position {pos1} and {pos2} of {field} in {section} is between {val1} and {val2}=(Positions1n2Values(xcb,{ruleID},{section},{field},{pos1},{pos2},{val1},{val2}))
[condition][]the {pos1} to {pos2} position of Rule {ruleID} multiple times {field} in {section} is less than or equal to {pos3} to {pos4} position=(posToPosOfTagIsLessThanOrEqualToPosToPos(xcb,{ruleID},{section},{field},{pos1},{pos2},{pos3},{pos4}))
[condition][]Rule {ruleID} multiple times {field} in {section} not_checkRepeationOFSpecialCharacter {format}=(not_checkRepeationOFSpecialCharacter(xcb,{ruleID},{section},{field},{format}))
[condition][]Rule {ruleID} multiple times {field} in {section} is AlphaNumeric=((isAlphaNumeric(xcb,{ruleID},{section},{field})))
[condition][]it is not true that_Rule {ruleID} multiple times {field} in {section} is AlphaNumeric=((isNotAlphaNumeric(xcb,{ruleID},{section},{field})))
[condition][]it is not true that_Rule {ruleID} multiple times_length of {field} in {section} is {value}=((LengthNotValue(xcb,{ruleID},{section},{field},{value})))
[condition][]Rule {ruleID} multiple times_length of {field} in {section} is {value}=((LengthValue(xcb,{ruleID},{section},{field},{value})))
[condition][]it is not true that_Rule {ruleID} multiple times {field} in {section} has telephone number format as {format}=((TelNumFormat(xcb,{ruleID},{section},{field},{format})))
[condition][]it is not true that_Rule {ruleID} multiple times {field} in {section} is AlphaNumeric_without following Special Character set {values}=((AlphaNumSpecialChar(xcb,{ruleID},{section},{field},{values})))
[condition][]Rule {ruleID} multiple times {field} in {section} is AlphaNumeric_without following Special Character set {values}=((AlphaNumNotSpecialChar(xcb,{ruleID},{section},{field},{values})))
[condition][]it is not true that_Rule {ruleID} multiple times_the {field} in {section} has a character {char} followed and preceeded by a numeric=(characterPreceededOrFollowedByNumeric(xcb,{ruleID},{section},{field},{char}))
[condition][]Rule {ruleID} multiple times_the {field} in {section} contains {values}=(containsfun(xcb,{ruleID},{section},{field},{values}))
[condition][]it is not true that_Rule {ruleID} multiple times_the {field} in {section} contains {values}=(notcontainsfun(xcb,{ruleID},{section},{field},{values}))
[condition][]it is not true that_Rule {ruleID} multiple times_characterFollowedByAlpha with {field} in {section} and {char}=(characterFollowedByAlpha(xcb,{ruleID},{section},{field},{char}))
[condition][]Rule {ruleID} multiple times_characterPreceededAndFollowedByAlpha with {field} in {section} and {char}=(characterPreceededAndFollowedByAlpha(xcb,{ruleID},{section},{field},{char}))
[condition][]it is not true that_Rule {ruleID} multiple times_characterPreceededAndFollowedByAlphaNumeric with {field} in {section} and {char}=(characterPreceededAndFollowedByAlphaNumeric(xcb,{ruleID},{section},{field},{char}))
[condition][]it is not true that_Rule {ruleID} multiple times_position {pos1} and {pos2} of {field} in {section} is equal to values {values}=(Positions1n2Equals(xcb,{ruleID},{section},{field},{pos1},{pos2},{values}))
[condition][]Rule {ruleID} multiple times_the field {field} in {section} contain character {char} followed by space=(characterFollowedBySpace(xcb,{ruleID},{section},{field},{char}))
[condition][]Rule {ruleID} multiple times_the field {field} in {section} contains_single paranthesis and not contained in another parenthesis=(checkSingleParanthesis(xcb,{ruleID},{section},{field}))
[condition][]it is not true that_Rule {ruleID} multiple times_the {field1} in {section} is not_equal to the field {field2}=((multiNotEqualsField(xcb,{ruleID},{section},{field1},(xcb.xpath({field2}).stringValue()))))
[condition][]Rule {ruleID} multiple times_the {field1} in {section} is not_equal to the field {field2}=((multiNotEquals(xcb,{ruleID},{section},{field1},(xcb.xpath({field2}).stringValue()))))
[condition][]Rule {ruleID} multiple times_the {field1} in {section} is less_than_field2 {field2}=((datefieldislessthanOrEqualfield(xcb,{ruleID},{section},{field1},(xcb.xpath({field2}).stringValue()))))
[condition][]it is not true that_Rule {ruleID} multiple times_the {field} in {section} contains_ampersand preceded by a space=((isAmpersandprecspace(xcb,{ruleID},{section},{field})))
[condition][]Rule {ruleID} multiple times {field} in {section} notValidDateFormat {format}=(notValidDateFormat(xcb,{ruleID},{section},{field},{format}))
[condition][]Rule {ruleID} multiple times_the {field} in {section} contains_double virgule and not preceeded and followed by alphanumeric=((doubleVirgleNotPreceededAndFollowedByAlphaNumeric(xcb,{ruleID},{section},{field})))
[condition][]The_Rule {ruleID} multiple times {field} in {section} is populated=(moExists(xcb,{ruleID},{section},{field}))
[condition][]The_Rule {ruleID} multiple times {field} in {section} is_not populated=(moNotExists(xcb,{ruleID},{section},{field}))
[condition][]check Request Exists In Database for {field1} and {field2} and {field3}=Fun_checkRequestExistsInDatabaseforVZE(xcb,{field1},{field2},{field3})
[condition][]check  ver change for the existing Request In Database for {field1} and {field2} and {field3}=Fun_checkVerChangeOrder(xcb,{field1},{field2},{field3})
[condition][]it is not true that_Rule {ruleID} multiple times {field} in {section} has value_ranges from {val1} to {val2}=(NotFieldIsInRangeBWtwoValues1(xcb,{ruleID},{section},{field},{val1},{val2}))
[condition][]Rule {ruleID} multiple times {field} in {section} has value_ranges from {val1} to {val2}=(FieldIsInRangeBWtwoValues1(xcb,{ruleID},{section},{field},{val1},{val2}))
[condition][]the field {field1} equals_to field {field2}=((new Equals()).isEquals(((xcb.xpath({field1})).stringValue()),((xcb.xpath({field2})).stringValue())))
[condition][]Any_occurrence_of {field} in {section} is_not_equal_to_field {field1}=(AnyOccOfFieldIsNotEqualfield(xcb,{section},{field},{field1}))
[condition][]it is not true that_Number of occurrence of {field} equal to {num}=(!(NoOfOccFieldEqualTo(xcb,{field},{num})))
[condition][]Number of occurrence of {field} equal to {num}=(NoOfOccFieldEqualTo(xcb,{field},{num}))
[condition][]it is not true that_Any occurrence of {field} in {section} is equal to {values}=(!(EachOccOfFieldIsEqualValues(xcb,{section},{field},{values})))
[condition][]Any occurrence of {field} in {section} has position {pos} is equal to {values}=(AnyOccOfFieldPosIsEqualValues(xcb,{section},{field},{pos},{values}))
[condition][]Any occurrence of {field} in {section} is equal to {values}=(EachOccOfFieldIsEqualValues(xcb,{section},{field},{values}))
[consequence][]call_Fun_DL_LACTMultiple_with error code {ecode} and message {emsg}=Fun_DL_LACTMultiple(xcb,{ecode},{emsg})
[consequence][]call_Fun_DL_LACTMultipleOther_with error code {ecode} and message {emsg}=Fun_DL_LACTMultipleOther(xcb,{ecode},{emsg})
[consequence][]call_Fun_EU_DIRQTYNCMultipleOTHER_with error code {ecode} and message {emsg}=Fun_EU_DIRQTYNCMultipleOTHER(xcb,{ecode},{emsg})
[consequence][]call_Fun_leaseOneOccOfRTY23EqualsMLFor_with error code {ecode} and message {emsg}=Fun_leaseOneOccOfRTY23EqualsMLFor(xcb,{ecode},{emsg})
[consequence][]call_Fun_SYSIDMultipleOR_with error code {ecode} and message {emsg}=Fun_SYSIDMultipleOR(xcb,{ecode},{emsg})
[consequence][]call_Fun_SYSIDMultipleORNegate_with error code {ecode} and message {emsg}=Fun_SYSIDMultipleORNegate(xcb,{ecode},{emsg})
[consequence][]call_Fun_CABLEIDMultipleOR_with error code {ecode} and message {emsg}=Fun_CABLEIDMultipleOR(xcb,{ecode},{emsg})
[consequence][]call_Fun_CABLEIDMultipleORNegate_with error code {ecode} and message {emsg}=Fun_CABLEIDMultipleORNegate(xcb,{ecode},{emsg})
[consequence][]call_Fun_LS_chanpairMultipleOTHER_with error code {ecode} and message {emsg}=Fun_LS_chanpairMultipleOTHER(xcb,{ecode},{emsg})
[consequence][]call_Fun_CBCID2MultipleOR_with error code {ecode} and message {emsg}=Fun_CBCID2MultipleOR(xcb,{ecode},{emsg})
[consequence][]call_Fun_SHELFMultipleOR_with error code {ecode} and message {emsg}=Fun_SHELFMultipleOR(xcb,{ecode},{emsg})
[consequence][]call_Fun_SHELFMultipleORNegate_with error code {ecode} and message {emsg}=Fun_SHELFMultipleORNegate(xcb,{ecode},{emsg})
[consequence][]call_Fun_CHAINPAIRMultipleOR_with error code {ecode} and message {emsg}=Fun_CHAINPAIRMultipleOR(xcb,{ecode},{emsg})
[consequence][]call_Fun_CHAINPAIRMultipleORNegate_with error code {ecode} and message {emsg}=Fun_CHAINPAIRMultipleORNegate(xcb,{ecode},{emsg})
[consequence][]call_Fun_LS_systemidMultipleOR_with error code {ecode} and message {emsg}=Fun_LS_systemidMultipleOR(xcb,{ecode},{emsg})
[consequence][]call_Fun_LS_systemidMultipleORNegate_with error code {ecode} and message {emsg}=Fun_LS_systemidMultipleORNegate(xcb,{ecode},{emsg})
[consequence][]call_Fun_LS_CTIMultipleOR_with error code {ecode} and message {emsg}=Fun_LS_CTIMultipleOR(xcb,{ecode},{emsg})
[consequence][]call_Fun_LS_cableidMultipleOR_with error code {ecode} and message {emsg}=Fun_LS_cableidMultipleOR(xcb,{ecode},{emsg})
[consequence][]call_Fun_LS_cableidMultipleORNegate_with error code {ecode} and message {emsg}=Fun_LS_cableidMultipleORNegate(xcb,{ecode},{emsg})
[consequence][]call_Fun_LS_SHELFMultipleOR_with error code {ecode} and message {emsg}=Fun_LS_SHELFMultipleOR(xcb,{ecode},{emsg})
[consequence][]call_Fun_LS_SHELFMultipleORNegate_with error code {ecode} and message {emsg}=Fun_LS_SHELFMultipleORNegate(xcb,{ecode},{emsg})
[consequence][]call_Fun_Fun_LS_SHELFMultipleOTHER_with error code {ecode} and message {emsg}=Fun_LS_SHELFMultipleOTHER(xcb,{ecode},{emsg})
[consequence][]call_Fun_LS_SHELFMultipleOTHERNegate_with error code {ecode} and message {emsg}=Fun_LS_SHELFMultipleOTHERNegate(xcb,{ecode},{emsg})
[consequence][]call_Fun_ADIMultipleOR_with error code {ecode} and message {emsg}=Fun_ADIMultipleOR(xcb,{ecode},{emsg})
[consequence][]call_Fun_LASF_SpecChar_with error code {ecode} and message {emsg}=Fun_LASF_SpecChar(xcb,{ecode},{emsg})
[condition][]it is not true that_All occurrence of {field} in {section} is equal to {values}=(!(ALLOccOfFieldIsEqualValues(xcb,{section},{field},{values})))
[condition][]All occurrence of {field} in {section} is equal to {values}=(ALLOccOfFieldIsEqualValues(xcb,{section},{field},{values}))
[condition][]Any occurrence of {field} in {section} is_not equal to {values}=(EachOccOfFieldIsNotEqualValues(xcb,{section},{field},{values}))
[condition][]Any occurrence of {field} in {section} is_not equal to_field {field2}=(EachOccOfFieldIsNotEqualValues(xcb,{section},{field},(xcb.xpath({field2}).stringValue())))
[condition][]always true=eval(true)
[condition][]the {pos1} and {pos2} of the {field} is in the range {start} to {end}=((new RangeOfValues()).twoFieldPositionInRange({pos1},{pos2},(xcb.xpath({field}).stringValue()),{start},{end}))
[condition][]the {pos1} and {pos2} of the {field} is_not in the range {start} to {end}=(!((new RangeOfValues()).twoFieldPositionInRange({pos1},{pos2},(xcb.xpath({field}).stringValue()),{start},{end})))
[condition][]the {pos} of the {field} is not numeric=(!((new DatatypeCheck()).checkPositionNumeric({pos},(xcb.xpath({field}).stringValue()))))
[condition][]the {pos} of the {field} is numeric=((new DatatypeCheck()).checkPositionNumeric({pos},(xcb.xpath({field}).stringValue())))
[condition][]it is not_true that the {field} has valid date=(!((new DateCheck()).isValidDate((xcb.xpath({field}).stringValue()))))
[condition][]the {field} has valid date=((new DateCheck()).isValidDate((xcb.xpath({field}).stringValue())))
[condition][]the_field {field1} is greater_than_the_field {field2}=((new Equals()).field1IsGreaterThanField2((xcb.xpath({field1}).stringValue()),(xcb.xpath({field2}).stringValue())))
[condition][]the field {field1} is_not_greater_than_field {field2}=(!((new Equals()).field1IsGreaterThanField2((xcb.xpath({field1}).stringValue()),(xcb.xpath({field2}).stringValue()))))
[condition][]the position {pos1} and {pos2} of {field} is less than position {pos3} and {pos4}=((new Position()).twoPositionValueofTagIsLessThanTheValueOfAnotherTwoPosition({pos1},{pos2},(xcb.xpath({field}).stringValue()),{pos3},{pos4}))
[condition][]it is not true that_the position {pos1} and {pos2} of {field} is less than position {pos3} and {pos4}=(!((new Position()).twoPositionValueofTagIsLessThanTheValueOfAnotherTwoPosition({pos1},{pos2},(xcb.xpath({field}).stringValue()),{pos3},{pos4})))
[condition][]the field {field} countPortedNbrRangevalues is {value}=(countPortedNbrRangevalues(xcb,(xcb.xpath({field}).stringValue()),{value}))
[condition][]the interval between {field1} and {field2} is equal to {value}=((new DateCheck()).intervalBetweenTwoDateIsEqualtoDays((xcb.xpath({field1}).stringValue()),(xcb.xpath({field2}).stringValue()),{value}))
[condition][]Rule {ruleID} multiple times {field} in {section} matches_the_pattern {pattern}=(multiplepatternmatches(xcb,{ruleID},{section},{field},{pattern}))
[condition][]it is not true that_Rule {ruleID} multiple times {field} in {section} do_not_matches_the_pattern {pattern}=(negatemultiplepatternNotmatches(xcb,{ruleID},{section},{field},{pattern}))
[condition][]Rule {ruleID} multiple times {field} in {section} do_not_matches_the_pattern {pattern}=(multiplepatternNotmatches(xcb,{ruleID},{section},{field},{pattern}))
[condition][]the_position {pos} of_field {field} is equal_to_values {values}=((new Contains()).positionOfFieldEqualToValues({pos},(xcb.xpath({field}).stringValue()),{values}))
[condition][]the existance space of {field} in the range from {value1} to {value2}=((new SpaceCheck()).existenceOfSpaceInSpecRange((xcb.xpath({field}).stringValue()),{value1},{value2}))
[condition][]it is not true that_the field value {field} is in the range from {value1} to {value2}=(!((new RangeOfValues()).rangeCheckNN_NN((xcb.xpath({field}).stringValue()),{value1},{value2})))
[condition][]the {field1} is not prohibited=((new Prohibited()).isNotProhibited((xcb.xpath({field1}).stringValue())))
[condition][]any occurence of the field {field} exists=(anyOccurenceExists(xcb,{field}))
[condition][]any_occurence_of_the_field {field1} not_equals to the_value {value}=(anyOccurenceNotEqualToValue(xcb,(xcb.xpath({field1}).stringValue()), {value}))

[condition][]Start Brace=(
[condition][]End Brace=)
[condition][]AND=&&
[condition][]OR=||
